// Code generated by Thrift Compiler (0.22.0). DO NOT EDIT.

package store

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"iter"
	"log/slog"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"strings"
	"regexp"
)

// (needed to ensure safety because of naive import list construction.)
var _ = bytes.Equal
var _ = context.Background
var _ = errors.New
var _ = fmt.Printf
var _ = iter.Pull[int]
var _ = slog.Log
var _ = time.Now
var _ = thrift.ZERO
// (needed by validator.)
var _ = strings.Contains
var _ = regexp.MatchString

// Attributes:
//  - ItemId
//  - Name
//  - Price
//  - Description
// 
type StoreItem struct {
	ItemId string `thrift:"itemId,1,required" db:"itemId" json:"itemId"`
	Name string `thrift:"name,2,required" db:"name" json:"name"`
	Price int64 `thrift:"price,3,required" db:"price" json:"price"`
	Description *string `thrift:"description,4" db:"description" json:"description,omitempty"`
}

func NewStoreItem() *StoreItem {
	return &StoreItem{}
}



func (p *StoreItem) GetItemId() string {
	return p.ItemId
}



func (p *StoreItem) GetName() string {
	return p.Name
}



func (p *StoreItem) GetPrice() int64 {
	return p.Price
}

var StoreItem_Description_DEFAULT string

func (p *StoreItem) GetDescription() string {
	if !p.IsSetDescription() {
		return StoreItem_Description_DEFAULT
	}
	return *p.Description
}

func (p *StoreItem) IsSetDescription() bool {
	return p.Description != nil
}

func (p *StoreItem) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetItemId bool = false;
	var issetName bool = false;
	var issetPrice bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetItemId = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetPrice = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetItemId{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ItemId is not set"))
	}
	if !issetName{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	if !issetPrice{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Price is not set"))
	}
	return nil
}

func (p *StoreItem) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *StoreItem) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *StoreItem) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Price = v
	}
	return nil
}

func (p *StoreItem) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Description = &v
	}
	return nil
}

func (p *StoreItem) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "StoreItem"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *StoreItem) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "itemId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:itemId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ItemId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.itemId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:itemId: ", p), err)
	}
	return err
}

func (p *StoreItem) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:name: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:name: ", p), err)
	}
	return err
}

func (p *StoreItem) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "price", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:price: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.Price)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.price (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:price: ", p), err)
	}
	return err
}

func (p *StoreItem) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDescription() {
		if err := oprot.WriteFieldBegin(ctx, "description", thrift.STRING, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:description: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.Description)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.description (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:description: ", p), err)
		}
	}
	return err
}

func (p *StoreItem) Equals(other *StoreItem) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.ItemId != other.ItemId { return false }
	if p.Name != other.Name { return false }
	if p.Price != other.Price { return false }
	if p.Description != other.Description {
		if p.Description == nil || other.Description == nil {
			return false
		}
		if (*p.Description) != (*other.Description) { return false }
	}
	return true
}

func (p *StoreItem) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("StoreItem(%+v)", *p)
}

func (p *StoreItem) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.StoreItem",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*StoreItem)(nil)

func (p *StoreItem) Validate() error {
	return nil
}

// Attributes:
//  - ItemId
//  - Amount
// 
type BasketItem struct {
	ItemId string `thrift:"itemId,1,required" db:"itemId" json:"itemId"`
	Amount int8 `thrift:"amount,2,required" db:"amount" json:"amount"`
}

func NewBasketItem() *BasketItem {
	return &BasketItem{}
}



func (p *BasketItem) GetItemId() string {
	return p.ItemId
}



func (p *BasketItem) GetAmount() int8 {
	return p.Amount
}

func (p *BasketItem) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetItemId bool = false;
	var issetAmount bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetItemId = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetAmount = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetItemId{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ItemId is not set"))
	}
	if !issetAmount{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Amount is not set"))
	}
	return nil
}

func (p *BasketItem) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *BasketItem) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := int8(v)
		p.Amount = temp
	}
	return nil
}

func (p *BasketItem) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "BasketItem"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *BasketItem) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "itemId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:itemId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ItemId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.itemId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:itemId: ", p), err)
	}
	return err
}

func (p *BasketItem) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "amount", thrift.BYTE, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:amount: ", p), err)
	}
	if err := oprot.WriteByte(ctx, int8(p.Amount)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.amount (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:amount: ", p), err)
	}
	return err
}

func (p *BasketItem) Equals(other *BasketItem) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.ItemId != other.ItemId { return false }
	if p.Amount != other.Amount { return false }
	return true
}

func (p *BasketItem) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BasketItem(%+v)", *p)
}

func (p *BasketItem) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.BasketItem",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*BasketItem)(nil)

func (p *BasketItem) Validate() error {
	return nil
}

// Attributes:
//  - BasketId
// 
type CreateBasketResponse struct {
	BasketId string `thrift:"basketId,1,required" db:"basketId" json:"basketId"`
}

func NewCreateBasketResponse() *CreateBasketResponse {
	return &CreateBasketResponse{}
}



func (p *CreateBasketResponse) GetBasketId() string {
	return p.BasketId
}

func (p *CreateBasketResponse) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetBasketId bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetBasketId = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetBasketId{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field BasketId is not set"))
	}
	return nil
}

func (p *CreateBasketResponse) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.BasketId = v
	}
	return nil
}

func (p *CreateBasketResponse) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CreateBasketResponse"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CreateBasketResponse) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "basketId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:basketId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.BasketId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.basketId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:basketId: ", p), err)
	}
	return err
}

func (p *CreateBasketResponse) Equals(other *CreateBasketResponse) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.BasketId != other.BasketId { return false }
	return true
}

func (p *CreateBasketResponse) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateBasketResponse(%+v)", *p)
}

func (p *CreateBasketResponse) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.CreateBasketResponse",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CreateBasketResponse)(nil)

func (p *CreateBasketResponse) Validate() error {
	return nil
}

// Attributes:
//  - Items
// 
type GetInventoryResponse struct {
	Items []*StoreItem `thrift:"items,1,required" db:"items" json:"items"`
}

func NewGetInventoryResponse() *GetInventoryResponse {
	return &GetInventoryResponse{}
}



func (p *GetInventoryResponse) GetItems() []*StoreItem {
	return p.Items
}

func (p *GetInventoryResponse) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetItems bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetItems = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetItems{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Items is not set"))
	}
	return nil
}

func (p *GetInventoryResponse) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*StoreItem, 0, size)
	p.Items = tSlice
	for i := 0; i < size; i++ {
		_elem0 := &StoreItem{}
		if err := _elem0.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
		}
		p.Items = append(p.Items, _elem0)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *GetInventoryResponse) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GetInventoryResponse"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *GetInventoryResponse) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "items", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:items: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Items)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Items {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:items: ", p), err)
	}
	return err
}

func (p *GetInventoryResponse) Equals(other *GetInventoryResponse) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Items) != len(other.Items) { return false }
	for i, _tgt := range p.Items {
		_src1 := other.Items[i]
		if !_tgt.Equals(_src1) { return false }
	}
	return true
}

func (p *GetInventoryResponse) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetInventoryResponse(%+v)", *p)
}

func (p *GetInventoryResponse) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.GetInventoryResponse",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*GetInventoryResponse)(nil)

func (p *GetInventoryResponse) Validate() error {
	return nil
}

// Attributes:
//  - Items
// 
type GetBasketResponse struct {
	Items []*BasketItem `thrift:"items,1,required" db:"items" json:"items"`
}

func NewGetBasketResponse() *GetBasketResponse {
	return &GetBasketResponse{}
}



func (p *GetBasketResponse) GetItems() []*BasketItem {
	return p.Items
}

func (p *GetBasketResponse) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetItems bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetItems = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetItems{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Items is not set"))
	}
	return nil
}

func (p *GetBasketResponse) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*BasketItem, 0, size)
	p.Items = tSlice
	for i := 0; i < size; i++ {
		_elem2 := &BasketItem{}
		if err := _elem2.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem2), err)
		}
		p.Items = append(p.Items, _elem2)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *GetBasketResponse) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GetBasketResponse"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *GetBasketResponse) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "items", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:items: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Items)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Items {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:items: ", p), err)
	}
	return err
}

func (p *GetBasketResponse) Equals(other *GetBasketResponse) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Items) != len(other.Items) { return false }
	for i, _tgt := range p.Items {
		_src3 := other.Items[i]
		if !_tgt.Equals(_src3) { return false }
	}
	return true
}

func (p *GetBasketResponse) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetBasketResponse(%+v)", *p)
}

func (p *GetBasketResponse) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.GetBasketResponse",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*GetBasketResponse)(nil)

func (p *GetBasketResponse) Validate() error {
	return nil
}

// Attributes:
//  - Flag
// 
type PayResponse struct {
	Flag *string `thrift:"flag,1" db:"flag" json:"flag,omitempty"`
}

func NewPayResponse() *PayResponse {
	return &PayResponse{}
}

var PayResponse_Flag_DEFAULT string

func (p *PayResponse) GetFlag() string {
	if !p.IsSetFlag() {
		return PayResponse_Flag_DEFAULT
	}
	return *p.Flag
}

func (p *PayResponse) IsSetFlag() bool {
	return p.Flag != nil
}

func (p *PayResponse) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *PayResponse) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Flag = &v
	}
	return nil
}

func (p *PayResponse) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "PayResponse"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *PayResponse) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetFlag() {
		if err := oprot.WriteFieldBegin(ctx, "flag", thrift.STRING, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:flag: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.Flag)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.flag (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:flag: ", p), err)
		}
	}
	return err
}

func (p *PayResponse) Equals(other *PayResponse) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Flag != other.Flag {
		if p.Flag == nil || other.Flag == nil {
			return false
		}
		if (*p.Flag) != (*other.Flag) { return false }
	}
	return true
}

func (p *PayResponse) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PayResponse(%+v)", *p)
}

func (p *PayResponse) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.PayResponse",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*PayResponse)(nil)

func (p *PayResponse) Validate() error {
	return nil
}

// Attributes:
//  - Message
// 
type BasketNotFound struct {
	Message string `thrift:"message,1,required" db:"message" json:"message"`
}

func NewBasketNotFound() *BasketNotFound {
	return &BasketNotFound{}
}



func (p *BasketNotFound) GetMessage() string {
	return p.Message
}

func (p *BasketNotFound) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetMessage bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetMessage = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetMessage{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Message is not set"))
	}
	return nil
}

func (p *BasketNotFound) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Message = v
	}
	return nil
}

func (p *BasketNotFound) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "BasketNotFound"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *BasketNotFound) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:message: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:message: ", p), err)
	}
	return err
}

func (p *BasketNotFound) Equals(other *BasketNotFound) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Message != other.Message { return false }
	return true
}

func (p *BasketNotFound) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BasketNotFound(%+v)", *p)
}

func (p *BasketNotFound) Error() string {
	return p.String()
}

func (BasketNotFound) TExceptionType() thrift.TExceptionType {
	return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*BasketNotFound)(nil)

func (p *BasketNotFound) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.BasketNotFound",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*BasketNotFound)(nil)

func (p *BasketNotFound) Validate() error {
	return nil
}

// Attributes:
//  - Message
// 
type ItemNotFound struct {
	Message string `thrift:"message,1,required" db:"message" json:"message"`
}

func NewItemNotFound() *ItemNotFound {
	return &ItemNotFound{}
}



func (p *ItemNotFound) GetMessage() string {
	return p.Message
}

func (p *ItemNotFound) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetMessage bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetMessage = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetMessage{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Message is not set"))
	}
	return nil
}

func (p *ItemNotFound) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Message = v
	}
	return nil
}

func (p *ItemNotFound) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "ItemNotFound"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ItemNotFound) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:message: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:message: ", p), err)
	}
	return err
}

func (p *ItemNotFound) Equals(other *ItemNotFound) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Message != other.Message { return false }
	return true
}

func (p *ItemNotFound) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ItemNotFound(%+v)", *p)
}

func (p *ItemNotFound) Error() string {
	return p.String()
}

func (ItemNotFound) TExceptionType() thrift.TExceptionType {
	return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*ItemNotFound)(nil)

func (p *ItemNotFound) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.ItemNotFound",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ItemNotFound)(nil)

func (p *ItemNotFound) Validate() error {
	return nil
}

// Attributes:
//  - Message
// 
type WrongTotal struct {
	Message string `thrift:"message,1,required" db:"message" json:"message"`
}

func NewWrongTotal() *WrongTotal {
	return &WrongTotal{}
}



func (p *WrongTotal) GetMessage() string {
	return p.Message
}

func (p *WrongTotal) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetMessage bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetMessage = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetMessage{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Message is not set"))
	}
	return nil
}

func (p *WrongTotal) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Message = v
	}
	return nil
}

func (p *WrongTotal) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "WrongTotal"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WrongTotal) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:message: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:message: ", p), err)
	}
	return err
}

func (p *WrongTotal) Equals(other *WrongTotal) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Message != other.Message { return false }
	return true
}

func (p *WrongTotal) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WrongTotal(%+v)", *p)
}

func (p *WrongTotal) Error() string {
	return p.String()
}

func (WrongTotal) TExceptionType() thrift.TExceptionType {
	return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*WrongTotal)(nil)

func (p *WrongTotal) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.WrongTotal",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*WrongTotal)(nil)

func (p *WrongTotal) Validate() error {
	return nil
}

type Store interface {
	CreateBasket(ctx context.Context) (_r *CreateBasketResponse, _err error)
	GetInventory(ctx context.Context) (_r *GetInventoryResponse, _err error)
	// Parameters:
	//  - BasketId
	// 
	GetBasket(ctx context.Context, basketId string) (_r *GetBasketResponse, _err error)
	// Parameters:
	//  - BasketId
	//  - ItemId
	// 
	AddToBasket(ctx context.Context, basketId string, itemId string) (_err error)
	// Parameters:
	//  - BasketId
	//  - Total
	// 
	Pay(ctx context.Context, basketId string, total int64) (_r *PayResponse, _err error)
}

type StoreClient struct {
	c thrift.TClient
	meta thrift.ResponseMeta
}

func NewStoreClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *StoreClient {
	return &StoreClient{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewStoreClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *StoreClient {
	return &StoreClient{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewStoreClient(c thrift.TClient) *StoreClient {
	return &StoreClient{
		c: c,
	}
}

func (p *StoreClient) Client_() thrift.TClient {
	return p.c
}

func (p *StoreClient) LastResponseMeta_() thrift.ResponseMeta {
	return p.meta
}

func (p *StoreClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
	p.meta = meta
}

func (p *StoreClient) CreateBasket(ctx context.Context) (_r *CreateBasketResponse, _err error) {
	var _args4 StoreCreateBasketArgs
	var _result6 StoreCreateBasketResult
	var _meta5 thrift.ResponseMeta
	_meta5, _err = p.Client_().Call(ctx, "createBasket", &_args4, &_result6)
	p.SetLastResponseMeta_(_meta5)
	if _err != nil {
		return
	}
	if _ret7 := _result6.GetSuccess(); _ret7 != nil {
		return _ret7, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "createBasket failed: unknown result")
}

func (p *StoreClient) GetInventory(ctx context.Context) (_r *GetInventoryResponse, _err error) {
	var _args8 StoreGetInventoryArgs
	var _result10 StoreGetInventoryResult
	var _meta9 thrift.ResponseMeta
	_meta9, _err = p.Client_().Call(ctx, "getInventory", &_args8, &_result10)
	p.SetLastResponseMeta_(_meta9)
	if _err != nil {
		return
	}
	if _ret11 := _result10.GetSuccess(); _ret11 != nil {
		return _ret11, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getInventory failed: unknown result")
}

// Parameters:
//  - BasketId
// 
func (p *StoreClient) GetBasket(ctx context.Context, basketId string) (_r *GetBasketResponse, _err error) {
	var _args12 StoreGetBasketArgs
	_args12.BasketId = basketId
	var _result14 StoreGetBasketResult
	var _meta13 thrift.ResponseMeta
	_meta13, _err = p.Client_().Call(ctx, "getBasket", &_args12, &_result14)
	p.SetLastResponseMeta_(_meta13)
	if _err != nil {
		return
	}
	switch {
	case _result14.BasketNotFound!= nil:
		return _r, _result14.BasketNotFound
	}

	if _ret15 := _result14.GetSuccess(); _ret15 != nil {
		return _ret15, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getBasket failed: unknown result")
}

// Parameters:
//  - BasketId
//  - ItemId
// 
func (p *StoreClient) AddToBasket(ctx context.Context, basketId string, itemId string) (_err error) {
	var _args16 StoreAddToBasketArgs
	_args16.BasketId = basketId
	_args16.ItemId = itemId
	var _result18 StoreAddToBasketResult
	var _meta17 thrift.ResponseMeta
	_meta17, _err = p.Client_().Call(ctx, "addToBasket", &_args16, &_result18)
	p.SetLastResponseMeta_(_meta17)
	if _err != nil {
		return
	}
	switch {
	case _result18.BasketNotFound!= nil:
		return _result18.BasketNotFound
	case _result18.ItemNotFound!= nil:
		return _result18.ItemNotFound
	}

	return nil
}

// Parameters:
//  - BasketId
//  - Total
// 
func (p *StoreClient) Pay(ctx context.Context, basketId string, total int64) (_r *PayResponse, _err error) {
	var _args19 StorePayArgs
	_args19.BasketId = basketId
	_args19.Total = total
	var _result21 StorePayResult
	var _meta20 thrift.ResponseMeta
	_meta20, _err = p.Client_().Call(ctx, "pay", &_args19, &_result21)
	p.SetLastResponseMeta_(_meta20)
	if _err != nil {
		return
	}
	switch {
	case _result21.BasketNotFound!= nil:
		return _r, _result21.BasketNotFound
	case _result21.WrongTotal!= nil:
		return _r, _result21.WrongTotal
	}

	if _ret22 := _result21.GetSuccess(); _ret22 != nil {
		return _ret22, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "pay failed: unknown result")
}

type StoreProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler Store
}

func (p *StoreProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *StoreProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *StoreProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewStoreProcessor(handler Store) *StoreProcessor {

	self23 := &StoreProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
	self23.processorMap["createBasket"] = &storeProcessorCreateBasket{handler:handler}
	self23.processorMap["getInventory"] = &storeProcessorGetInventory{handler:handler}
	self23.processorMap["getBasket"] = &storeProcessorGetBasket{handler:handler}
	self23.processorMap["addToBasket"] = &storeProcessorAddToBasket{handler:handler}
	self23.processorMap["pay"] = &storeProcessorPay{handler:handler}
	return self23
}

func (p *StoreProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
	if err2 != nil { return false, thrift.WrapTException(err2) }
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(ctx, thrift.STRUCT)
	iprot.ReadMessageEnd(ctx)
	x24 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
	oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
	x24.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return false, x24
}

type storeProcessorCreateBasket struct {
	handler Store
}

func (p *storeProcessorCreateBasket) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err25 thrift.TException
	args := StoreCreateBasketArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "createBasket", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := StoreCreateBasketResult{}
	if retval, err2 := p.handler.CreateBasket(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, &thrift.ProcessorError{
				WriteError:    thrift.WrapTException(err2),
				EndpointError: err,
			}
		}
		if errors.Is(err2, context.Canceled) {
			if err3 := context.Cause(ctx); errors.Is(err3, thrift.ErrAbandonRequest) {
				return false, &thrift.ProcessorError{
					WriteError:    thrift.WrapTException(err3),
					EndpointError: err,
				}
			}
		}
		_exc26 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createBasket: " + err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "createBasket", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err25 = thrift.WrapTException(err2)
		}
		if err2 := _exc26.Write(ctx, oprot); _write_err25 == nil && err2 != nil {
			_write_err25 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err25 == nil && err2 != nil {
			_write_err25 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err25 == nil && err2 != nil {
			_write_err25 = thrift.WrapTException(err2)
		}
		if _write_err25 != nil {
			return false, &thrift.ProcessorError{
				WriteError:    _write_err25,
				EndpointError: err,
			}
		}
		return true, err
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "createBasket", thrift.REPLY, seqId); err2 != nil {
		_write_err25 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err25 == nil && err2 != nil {
		_write_err25 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err25 == nil && err2 != nil {
		_write_err25 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err25 == nil && err2 != nil {
		_write_err25 = thrift.WrapTException(err2)
	}
	if _write_err25 != nil {
		return false, &thrift.ProcessorError{
			WriteError:    _write_err25,
			EndpointError: err,
		}
	}
	return true, err
}

type storeProcessorGetInventory struct {
	handler Store
}

func (p *storeProcessorGetInventory) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err27 thrift.TException
	args := StoreGetInventoryArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getInventory", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := StoreGetInventoryResult{}
	if retval, err2 := p.handler.GetInventory(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, &thrift.ProcessorError{
				WriteError:    thrift.WrapTException(err2),
				EndpointError: err,
			}
		}
		if errors.Is(err2, context.Canceled) {
			if err3 := context.Cause(ctx); errors.Is(err3, thrift.ErrAbandonRequest) {
				return false, &thrift.ProcessorError{
					WriteError:    thrift.WrapTException(err3),
					EndpointError: err,
				}
			}
		}
		_exc28 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getInventory: " + err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "getInventory", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err27 = thrift.WrapTException(err2)
		}
		if err2 := _exc28.Write(ctx, oprot); _write_err27 == nil && err2 != nil {
			_write_err27 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err27 == nil && err2 != nil {
			_write_err27 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err27 == nil && err2 != nil {
			_write_err27 = thrift.WrapTException(err2)
		}
		if _write_err27 != nil {
			return false, &thrift.ProcessorError{
				WriteError:    _write_err27,
				EndpointError: err,
			}
		}
		return true, err
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getInventory", thrift.REPLY, seqId); err2 != nil {
		_write_err27 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err27 == nil && err2 != nil {
		_write_err27 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err27 == nil && err2 != nil {
		_write_err27 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err27 == nil && err2 != nil {
		_write_err27 = thrift.WrapTException(err2)
	}
	if _write_err27 != nil {
		return false, &thrift.ProcessorError{
			WriteError:    _write_err27,
			EndpointError: err,
		}
	}
	return true, err
}

type storeProcessorGetBasket struct {
	handler Store
}

func (p *storeProcessorGetBasket) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err29 thrift.TException
	args := StoreGetBasketArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getBasket", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := StoreGetBasketResult{}
	if retval, err2 := p.handler.GetBasket(ctx, args.BasketId); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *BasketNotFound:
			result.BasketNotFound = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, &thrift.ProcessorError{
					WriteError:    thrift.WrapTException(err2),
					EndpointError: err,
				}
			}
			if errors.Is(err2, context.Canceled) {
				if err3 := context.Cause(ctx); errors.Is(err3, thrift.ErrAbandonRequest) {
					return false, &thrift.ProcessorError{
						WriteError:    thrift.WrapTException(err3),
						EndpointError: err,
					}
				}
			}
			_exc30 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getBasket: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getBasket", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err29 = thrift.WrapTException(err2)
			}
			if err2 := _exc30.Write(ctx, oprot); _write_err29 == nil && err2 != nil {
				_write_err29 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err29 == nil && err2 != nil {
				_write_err29 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err29 == nil && err2 != nil {
				_write_err29 = thrift.WrapTException(err2)
			}
			if _write_err29 != nil {
				return false, &thrift.ProcessorError{
					WriteError:    _write_err29,
					EndpointError: err,
				}
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getBasket", thrift.REPLY, seqId); err2 != nil {
		_write_err29 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err29 == nil && err2 != nil {
		_write_err29 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err29 == nil && err2 != nil {
		_write_err29 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err29 == nil && err2 != nil {
		_write_err29 = thrift.WrapTException(err2)
	}
	if _write_err29 != nil {
		return false, &thrift.ProcessorError{
			WriteError:    _write_err29,
			EndpointError: err,
		}
	}
	return true, err
}

type storeProcessorAddToBasket struct {
	handler Store
}

func (p *storeProcessorAddToBasket) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err31 thrift.TException
	args := StoreAddToBasketArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "addToBasket", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := StoreAddToBasketResult{}
	if err2 := p.handler.AddToBasket(ctx, args.BasketId, args.ItemId); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *BasketNotFound:
			result.BasketNotFound = v
		case *ItemNotFound:
			result.ItemNotFound = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, &thrift.ProcessorError{
					WriteError:    thrift.WrapTException(err2),
					EndpointError: err,
				}
			}
			if errors.Is(err2, context.Canceled) {
				if err3 := context.Cause(ctx); errors.Is(err3, thrift.ErrAbandonRequest) {
					return false, &thrift.ProcessorError{
						WriteError:    thrift.WrapTException(err3),
						EndpointError: err,
					}
				}
			}
			_exc32 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing addToBasket: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "addToBasket", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err31 = thrift.WrapTException(err2)
			}
			if err2 := _exc32.Write(ctx, oprot); _write_err31 == nil && err2 != nil {
				_write_err31 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err31 == nil && err2 != nil {
				_write_err31 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err31 == nil && err2 != nil {
				_write_err31 = thrift.WrapTException(err2)
			}
			if _write_err31 != nil {
				return false, &thrift.ProcessorError{
					WriteError:    _write_err31,
					EndpointError: err,
				}
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "addToBasket", thrift.REPLY, seqId); err2 != nil {
		_write_err31 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err31 == nil && err2 != nil {
		_write_err31 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err31 == nil && err2 != nil {
		_write_err31 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err31 == nil && err2 != nil {
		_write_err31 = thrift.WrapTException(err2)
	}
	if _write_err31 != nil {
		return false, &thrift.ProcessorError{
			WriteError:    _write_err31,
			EndpointError: err,
		}
	}
	return true, err
}

type storeProcessorPay struct {
	handler Store
}

func (p *storeProcessorPay) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err33 thrift.TException
	args := StorePayArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "pay", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := StorePayResult{}
	if retval, err2 := p.handler.Pay(ctx, args.BasketId, args.Total); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *BasketNotFound:
			result.BasketNotFound = v
		case *WrongTotal:
			result.WrongTotal = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, &thrift.ProcessorError{
					WriteError:    thrift.WrapTException(err2),
					EndpointError: err,
				}
			}
			if errors.Is(err2, context.Canceled) {
				if err3 := context.Cause(ctx); errors.Is(err3, thrift.ErrAbandonRequest) {
					return false, &thrift.ProcessorError{
						WriteError:    thrift.WrapTException(err3),
						EndpointError: err,
					}
				}
			}
			_exc34 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing pay: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "pay", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err33 = thrift.WrapTException(err2)
			}
			if err2 := _exc34.Write(ctx, oprot); _write_err33 == nil && err2 != nil {
				_write_err33 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err33 == nil && err2 != nil {
				_write_err33 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err33 == nil && err2 != nil {
				_write_err33 = thrift.WrapTException(err2)
			}
			if _write_err33 != nil {
				return false, &thrift.ProcessorError{
					WriteError:    _write_err33,
					EndpointError: err,
				}
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "pay", thrift.REPLY, seqId); err2 != nil {
		_write_err33 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err33 == nil && err2 != nil {
		_write_err33 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err33 == nil && err2 != nil {
		_write_err33 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err33 == nil && err2 != nil {
		_write_err33 = thrift.WrapTException(err2)
	}
	if _write_err33 != nil {
		return false, &thrift.ProcessorError{
			WriteError:    _write_err33,
			EndpointError: err,
		}
	}
	return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

type StoreCreateBasketArgs struct {
}

func NewStoreCreateBasketArgs() *StoreCreateBasketArgs {
	return &StoreCreateBasketArgs{}
}

func (p *StoreCreateBasketArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *StoreCreateBasketArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createBasket_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *StoreCreateBasketArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("StoreCreateBasketArgs(%+v)", *p)
}

func (p *StoreCreateBasketArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.StoreCreateBasketArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*StoreCreateBasketArgs)(nil)

// Attributes:
//  - Success
// 
type StoreCreateBasketResult struct {
	Success *CreateBasketResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewStoreCreateBasketResult() *StoreCreateBasketResult {
	return &StoreCreateBasketResult{}
}

var StoreCreateBasketResult_Success_DEFAULT *CreateBasketResponse

func (p *StoreCreateBasketResult) GetSuccess() *CreateBasketResponse {
	if !p.IsSetSuccess() {
		return StoreCreateBasketResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StoreCreateBasketResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StoreCreateBasketResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *StoreCreateBasketResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &CreateBasketResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *StoreCreateBasketResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "createBasket_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *StoreCreateBasketResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *StoreCreateBasketResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("StoreCreateBasketResult(%+v)", *p)
}

func (p *StoreCreateBasketResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.StoreCreateBasketResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*StoreCreateBasketResult)(nil)

type StoreGetInventoryArgs struct {
}

func NewStoreGetInventoryArgs() *StoreGetInventoryArgs {
	return &StoreGetInventoryArgs{}
}

func (p *StoreGetInventoryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *StoreGetInventoryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getInventory_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *StoreGetInventoryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("StoreGetInventoryArgs(%+v)", *p)
}

func (p *StoreGetInventoryArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.StoreGetInventoryArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*StoreGetInventoryArgs)(nil)

// Attributes:
//  - Success
// 
type StoreGetInventoryResult struct {
	Success *GetInventoryResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewStoreGetInventoryResult() *StoreGetInventoryResult {
	return &StoreGetInventoryResult{}
}

var StoreGetInventoryResult_Success_DEFAULT *GetInventoryResponse

func (p *StoreGetInventoryResult) GetSuccess() *GetInventoryResponse {
	if !p.IsSetSuccess() {
		return StoreGetInventoryResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StoreGetInventoryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StoreGetInventoryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *StoreGetInventoryResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &GetInventoryResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *StoreGetInventoryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getInventory_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *StoreGetInventoryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *StoreGetInventoryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("StoreGetInventoryResult(%+v)", *p)
}

func (p *StoreGetInventoryResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.StoreGetInventoryResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*StoreGetInventoryResult)(nil)

// Attributes:
//  - BasketId
// 
type StoreGetBasketArgs struct {
	BasketId string `thrift:"basketId,1" db:"basketId" json:"basketId"`
}

func NewStoreGetBasketArgs() *StoreGetBasketArgs {
	return &StoreGetBasketArgs{}
}



func (p *StoreGetBasketArgs) GetBasketId() string {
	return p.BasketId
}

func (p *StoreGetBasketArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *StoreGetBasketArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.BasketId = v
	}
	return nil
}

func (p *StoreGetBasketArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getBasket_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *StoreGetBasketArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "basketId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:basketId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.BasketId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.basketId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:basketId: ", p), err)
	}
	return err
}

func (p *StoreGetBasketArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("StoreGetBasketArgs(%+v)", *p)
}

func (p *StoreGetBasketArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.StoreGetBasketArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*StoreGetBasketArgs)(nil)

// Attributes:
//  - Success
//  - BasketNotFound
// 
type StoreGetBasketResult struct {
	Success *GetBasketResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	BasketNotFound *BasketNotFound `thrift:"basketNotFound,1" db:"basketNotFound" json:"basketNotFound,omitempty"`
}

func NewStoreGetBasketResult() *StoreGetBasketResult {
	return &StoreGetBasketResult{}
}

var StoreGetBasketResult_Success_DEFAULT *GetBasketResponse

func (p *StoreGetBasketResult) GetSuccess() *GetBasketResponse {
	if !p.IsSetSuccess() {
		return StoreGetBasketResult_Success_DEFAULT
	}
	return p.Success
}

var StoreGetBasketResult_BasketNotFound_DEFAULT *BasketNotFound

func (p *StoreGetBasketResult) GetBasketNotFound() *BasketNotFound {
	if !p.IsSetBasketNotFound() {
		return StoreGetBasketResult_BasketNotFound_DEFAULT
	}
	return p.BasketNotFound
}

func (p *StoreGetBasketResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StoreGetBasketResult) IsSetBasketNotFound() bool {
	return p.BasketNotFound != nil
}

func (p *StoreGetBasketResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *StoreGetBasketResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &GetBasketResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *StoreGetBasketResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.BasketNotFound = &BasketNotFound{}
	if err := p.BasketNotFound.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.BasketNotFound), err)
	}
	return nil
}

func (p *StoreGetBasketResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getBasket_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *StoreGetBasketResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *StoreGetBasketResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetBasketNotFound() {
		if err := oprot.WriteFieldBegin(ctx, "basketNotFound", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:basketNotFound: ", p), err)
		}
		if err := p.BasketNotFound.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.BasketNotFound), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:basketNotFound: ", p), err)
		}
	}
	return err
}

func (p *StoreGetBasketResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("StoreGetBasketResult(%+v)", *p)
}

func (p *StoreGetBasketResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.StoreGetBasketResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*StoreGetBasketResult)(nil)

// Attributes:
//  - BasketId
//  - ItemId
// 
type StoreAddToBasketArgs struct {
	BasketId string `thrift:"basketId,1" db:"basketId" json:"basketId"`
	ItemId string `thrift:"itemId,2" db:"itemId" json:"itemId"`
}

func NewStoreAddToBasketArgs() *StoreAddToBasketArgs {
	return &StoreAddToBasketArgs{}
}



func (p *StoreAddToBasketArgs) GetBasketId() string {
	return p.BasketId
}



func (p *StoreAddToBasketArgs) GetItemId() string {
	return p.ItemId
}

func (p *StoreAddToBasketArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *StoreAddToBasketArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.BasketId = v
	}
	return nil
}

func (p *StoreAddToBasketArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *StoreAddToBasketArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "addToBasket_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *StoreAddToBasketArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "basketId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:basketId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.BasketId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.basketId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:basketId: ", p), err)
	}
	return err
}

func (p *StoreAddToBasketArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "itemId", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:itemId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ItemId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.itemId (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:itemId: ", p), err)
	}
	return err
}

func (p *StoreAddToBasketArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("StoreAddToBasketArgs(%+v)", *p)
}

func (p *StoreAddToBasketArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.StoreAddToBasketArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*StoreAddToBasketArgs)(nil)

// Attributes:
//  - BasketNotFound
//  - ItemNotFound
// 
type StoreAddToBasketResult struct {
	BasketNotFound *BasketNotFound `thrift:"basketNotFound,1" db:"basketNotFound" json:"basketNotFound,omitempty"`
	ItemNotFound *ItemNotFound `thrift:"itemNotFound,2" db:"itemNotFound" json:"itemNotFound,omitempty"`
}

func NewStoreAddToBasketResult() *StoreAddToBasketResult {
	return &StoreAddToBasketResult{}
}

var StoreAddToBasketResult_BasketNotFound_DEFAULT *BasketNotFound

func (p *StoreAddToBasketResult) GetBasketNotFound() *BasketNotFound {
	if !p.IsSetBasketNotFound() {
		return StoreAddToBasketResult_BasketNotFound_DEFAULT
	}
	return p.BasketNotFound
}

var StoreAddToBasketResult_ItemNotFound_DEFAULT *ItemNotFound

func (p *StoreAddToBasketResult) GetItemNotFound() *ItemNotFound {
	if !p.IsSetItemNotFound() {
		return StoreAddToBasketResult_ItemNotFound_DEFAULT
	}
	return p.ItemNotFound
}

func (p *StoreAddToBasketResult) IsSetBasketNotFound() bool {
	return p.BasketNotFound != nil
}

func (p *StoreAddToBasketResult) IsSetItemNotFound() bool {
	return p.ItemNotFound != nil
}

func (p *StoreAddToBasketResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *StoreAddToBasketResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.BasketNotFound = &BasketNotFound{}
	if err := p.BasketNotFound.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.BasketNotFound), err)
	}
	return nil
}

func (p *StoreAddToBasketResult) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.ItemNotFound = &ItemNotFound{}
	if err := p.ItemNotFound.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ItemNotFound), err)
	}
	return nil
}

func (p *StoreAddToBasketResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "addToBasket_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *StoreAddToBasketResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetBasketNotFound() {
		if err := oprot.WriteFieldBegin(ctx, "basketNotFound", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:basketNotFound: ", p), err)
		}
		if err := p.BasketNotFound.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.BasketNotFound), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:basketNotFound: ", p), err)
		}
	}
	return err
}

func (p *StoreAddToBasketResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetItemNotFound() {
		if err := oprot.WriteFieldBegin(ctx, "itemNotFound", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:itemNotFound: ", p), err)
		}
		if err := p.ItemNotFound.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ItemNotFound), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:itemNotFound: ", p), err)
		}
	}
	return err
}

func (p *StoreAddToBasketResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("StoreAddToBasketResult(%+v)", *p)
}

func (p *StoreAddToBasketResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.StoreAddToBasketResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*StoreAddToBasketResult)(nil)

// Attributes:
//  - BasketId
//  - Total
// 
type StorePayArgs struct {
	BasketId string `thrift:"basketId,1" db:"basketId" json:"basketId"`
	Total int64 `thrift:"total,2" db:"total" json:"total"`
}

func NewStorePayArgs() *StorePayArgs {
	return &StorePayArgs{}
}



func (p *StorePayArgs) GetBasketId() string {
	return p.BasketId
}



func (p *StorePayArgs) GetTotal() int64 {
	return p.Total
}

func (p *StorePayArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *StorePayArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.BasketId = v
	}
	return nil
}

func (p *StorePayArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Total = v
	}
	return nil
}

func (p *StorePayArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "pay_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *StorePayArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "basketId", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:basketId: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.BasketId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.basketId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:basketId: ", p), err)
	}
	return err
}

func (p *StorePayArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "total", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:total: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.Total)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.total (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:total: ", p), err)
	}
	return err
}

func (p *StorePayArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("StorePayArgs(%+v)", *p)
}

func (p *StorePayArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.StorePayArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*StorePayArgs)(nil)

// Attributes:
//  - Success
//  - BasketNotFound
//  - WrongTotal
// 
type StorePayResult struct {
	Success *PayResponse `thrift:"success,0" db:"success" json:"success,omitempty"`
	BasketNotFound *BasketNotFound `thrift:"basketNotFound,1" db:"basketNotFound" json:"basketNotFound,omitempty"`
	WrongTotal *WrongTotal `thrift:"wrongTotal,2" db:"wrongTotal" json:"wrongTotal,omitempty"`
}

func NewStorePayResult() *StorePayResult {
	return &StorePayResult{}
}

var StorePayResult_Success_DEFAULT *PayResponse

func (p *StorePayResult) GetSuccess() *PayResponse {
	if !p.IsSetSuccess() {
		return StorePayResult_Success_DEFAULT
	}
	return p.Success
}

var StorePayResult_BasketNotFound_DEFAULT *BasketNotFound

func (p *StorePayResult) GetBasketNotFound() *BasketNotFound {
	if !p.IsSetBasketNotFound() {
		return StorePayResult_BasketNotFound_DEFAULT
	}
	return p.BasketNotFound
}

var StorePayResult_WrongTotal_DEFAULT *WrongTotal

func (p *StorePayResult) GetWrongTotal() *WrongTotal {
	if !p.IsSetWrongTotal() {
		return StorePayResult_WrongTotal_DEFAULT
	}
	return p.WrongTotal
}

func (p *StorePayResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StorePayResult) IsSetBasketNotFound() bool {
	return p.BasketNotFound != nil
}

func (p *StorePayResult) IsSetWrongTotal() bool {
	return p.WrongTotal != nil
}

func (p *StorePayResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *StorePayResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &PayResponse{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *StorePayResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.BasketNotFound = &BasketNotFound{}
	if err := p.BasketNotFound.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.BasketNotFound), err)
	}
	return nil
}

func (p *StorePayResult) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.WrongTotal = &WrongTotal{}
	if err := p.WrongTotal.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.WrongTotal), err)
	}
	return nil
}

func (p *StorePayResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "pay_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *StorePayResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *StorePayResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetBasketNotFound() {
		if err := oprot.WriteFieldBegin(ctx, "basketNotFound", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:basketNotFound: ", p), err)
		}
		if err := p.BasketNotFound.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.BasketNotFound), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:basketNotFound: ", p), err)
		}
	}
	return err
}

func (p *StorePayResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetWrongTotal() {
		if err := oprot.WriteFieldBegin(ctx, "wrongTotal", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:wrongTotal: ", p), err)
		}
		if err := p.WrongTotal.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.WrongTotal), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:wrongTotal: ", p), err)
		}
	}
	return err
}

func (p *StorePayResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("StorePayResult(%+v)", *p)
}

func (p *StorePayResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*store.StorePayResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*StorePayResult)(nil)


